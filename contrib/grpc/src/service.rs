//! Service utilities and traits for gRPC integration with Rocket.

/// A trait for gRPC services that can access Rocket's managed state.
///
/// This trait provides a convenient way to access Rocket's managed state
/// from within gRPC service implementations.
#[cfg(feature = "tonic")]
pub trait GrpcService<T> {
    /// Get access to Rocket's managed state of type T.
    ///
    /// This method returns `None` if the state is not available,
    /// which can happen if the state wasn't registered with Rocket
    /// or if called outside a gRPC service context with state access.
    fn state(&self) -> Option<&T>;
}

/// A wrapper that provides access to Rocket's managed state from gRPC services.
///
/// This struct can be used to wrap your gRPC service implementations
/// to give them access to Rocket's managed state.
#[cfg(feature = "tonic")]
#[derive(Clone)]
pub struct StateAwareService<S, T> {
    service: S,
    state: Option<T>,
}

#[cfg(feature = "tonic")]
impl<S, T> StateAwareService<S, T> {
    /// Create a new state-aware service wrapper.
    pub fn new(service: S, state: T) -> Self {
        Self {
            service,
            state: Some(state),
        }
    }

    /// Create a new state-aware service without state.
    pub fn without_state(service: S) -> Self {
        Self {
            service,
            state: None,
        }
    }

    /// Get a reference to the wrapped service.
    pub fn service(&self) -> &S {
        &self.service
    }

    /// Get a reference to the state, if available.
    pub fn state(&self) -> Option<&T> {
        self.state.as_ref()
    }
}

/// Helper macro to create a gRPC service with Rocket state access.
///
/// This macro simplifies the creation of gRPC services that need access
/// to Rocket's managed state.
///
/// # Example
///
/// ```rust,ignore
/// use rocket_grpc::grpc_service;
/// use tonic::{Request, Response, Status};
///
/// // Example types (would normally be generated by tonic from proto files)
/// struct MyAppState {
///     counter: u64,
/// }
/// 
/// struct HelloRequest {
///     name: String,
/// }
/// 
/// struct HelloReply {
///     message: String,
/// }
///
/// grpc_service! {
///     MyGreeter {
///         state: MyAppState,
///         
///         async fn say_hello(&self, request: Request<HelloRequest>) 
///             -> Result<Response<HelloReply>, Status> {
///             let app_state = self.state().unwrap();
///             // Use app_state here...
///             Ok(Response::new(HelloReply {
///                 message: format!("Hello, {}!", request.into_inner().name),
///             }))
///         }
///     }
/// }
/// ```
#[cfg(feature = "tonic")]
#[macro_export]
macro_rules! grpc_service {
    (
        $service_name:ident {
            state: $state_type:ty,
            $($method:item)*
        }
    ) => {
        #[derive(Clone)]
        pub struct $service_name {
            state: Option<$state_type>,
        }

        impl $service_name {
            pub fn new(state: $state_type) -> Self {
                Self { state: Some(state) }
            }

            pub fn without_state() -> Self {
                Self { state: None }
            }

            pub fn state(&self) -> Option<&$state_type> {
                self.state.as_ref()
            }
        }

        impl $service_name {
            $($method)*
        }
    };
}

/// Utility function to extract gRPC metadata as a Rocket-style header map.
///
/// This function converts tonic's metadata format into something more
/// familiar to Rocket users.
#[cfg(feature = "tonic")]
pub fn metadata_to_headers(
    metadata: &tonic::metadata::MetadataMap,
) -> std::collections::HashMap<String, String> {
    metadata
        .iter()
        .filter_map(|entry| {
            match entry {
                tonic::metadata::KeyAndValueRef::Ascii(key, value) => {
                    Some((key.as_str().to_string(), value.to_str().ok()?.to_string()))
                }
                tonic::metadata::KeyAndValueRef::Binary(_key, _value) => {
                    // Skip binary metadata for now
                    None
                }
            }
        })
        .collect()
}